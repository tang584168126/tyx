IDE 集成开发环境

IDE(VS) 	  :2002 2003 2005 2008 		2010、2012		2013
.NET Framework:1.0  1.1  2.0  3.0 3.5      4.0 			4.5

.NET平台主要包含两大块：CLR(公共语音运行时)、FCL(框架类库)
CLS(公共语音规范)、CTS(通用语音系统)、IL(中间语言)

C#源代码编译流程：首先通过C#编译器编译为IL代码，然后在CLR中通过JIT编译器编译为机器码

引用一个命名空间，要确保这个命名空间所在的程序集已经被引用到项目中

public class 类名 	类的默认访问修饰符：internal
{
}

C#中的基本数据类型本质上是.NET Framework中定义的数据类型的别名
System.Single  float
System.String  string

变量命名构成：数字、字母、下划线
变量名不能为关键字，变量命名首字母只能是字母和下划线，C#中是区分大小写
C#常用的命名规则有：Camel命名法 => 字段、参赛
					Pascal命名法 =>类名、方法名、属性名
					
转义序列：\',\\,\",\b,\r,\n,\t		"sdfks\"hdf"
逐字指定的字符串		@"sdfks"hdf"

隐式类型转换 => 将类型范围小的数据转化为取值范围更大的类型
显示类型转换 => 将类型范围大的数据转化为取值范围更小的类型
数字型字符串转换为数值 => int.Parse(数字型字符串)
Convert类(包含大量的重载方法) => 通用型转换

注释：
单行注释：		//
多行注释：		/*	*/
文档注释：一般用于类、方法、属性			///
代码折叠：#region		#endregion

枚举：enum	枚举名{}	定义一组有限的值，不能包括方法，对可能的值进行约束		枚举数表示的是整数值，初始值默认从0开始
	用来一一列举可能出现的值，以对值进行约束,值类型，数据存放栈中
	enum Gender
	{
		Male,Female
	}
	枚举与字符串的转换
	Gender.Male.ToString() =》 "Male"
	"Male" => (Gender)(Enum.Parse(typeof(Gender),"Male"))
	不能实例化
	转化为字符串 =>ToString()
	转换为枚举 => (枚举类型)
	
结构：与类对应，是一种值类型，数据存放在栈中
struct 结构名
{

}	
结构中没有默认的构造函数，但可以自定义构造函数，定义结构时不远new

值类型：除string之外的基本数据类型、枚举、结构
引用类型：string、类、接口、委托、数组

调试本质：对比期望值和实际值

类：对现实世界同类事物的共有特征和行为的抽象
对象：类的实例，表示一个具体的事物

用new创建一个类的对象时，将为对象分配一块空间，每一个对象都有不同的内存，两个不同的对象，
即使他们的所有成员的值或代码都相同，他们也是不相等的

构造函数：
	1.没有返回值类型
	2.名称与类名一致
	3.专门用于初始化对象的值
	4.类中至少要有一个构造函数，如果没有自定义，系统默认会给一个无参构造函数，如果没有定义，系统不再提供

私有构造函数 => 单例模式
publuc class Player	
{
	//私有的实例
	private static Player instance;
	//私有构造函数
	private Player()
	{
		//实例化
	}
	
	public static Player GetInstance()
	{
		if(instance != null)
		{
			return instance;
		}
		return  new Player();
	}
}

静态成员：
	1.静态成员用static修饰的成员
	2.只能通过类名使用"."运算符来引用
	3.静态成员被所有的实例对象所共用，它在第一次实例化对象时在内存中分配空间并赋值
	4.静态函数成员的代码体内只能直接引用类的静态成员
	
实例成员：
		1.没有static修饰
		2.只能通过对象名使用"."运算符来使用
		3.实例化多少个对象，那么在内存中创建多少个实例成员副本
		4.实例函数成员的代码体内可以直接引用类的静态成员和实例成员
		
属性：主要用来封装类中的私有字段，提供代码的安全性和灵活性，属性分只读属性，只写属性以及读写属性
	属性定义的规范：
		1.用属性封装的私有字段，通常以下划线开头、以小写单词命名
		2.将字段的单词首字母大写作为属性的名称
		3.属性前加文档注释，说明属性含义
		4.属性与字段一一对应，且属性的类型与其对应的字段类型必须一致
	自动属性：
		使用条件：	
			1.读写数据是没有逻辑判断
			2.是读写属性
			快捷方式：prop+tab+tab

方法重载：对不同数据使用相同的出来方式
	重载方法具体体现在：方法名相同，参数列表不同(参数个数，参数类型)
	
方法传参：
	以值方式传递值类型数据			没有用ref或out想修饰参数
	---------------------------
	以值方式传递引用类型数据		
	以引用方式传递值类型数据
	以引用方式传递引用类型数据	
	
C#中类只能单继承(一个类只能有一个父类)，但是可以继承多个接口，接口之间用","隔开	

构造函数的执行序列：
	1.实例化派生类，必须先实例化他的基类，而要实例化这个基类，又必须实例化这个基类的基类，一直实例化到System.Object()为止
	2.即：在类的继承结构体系中，实例化一个派生类，要从其最顶层基类开始依次向下执行构造函数
	
方法重写(override)：子类重新实现定义在父类中相同的方法，且在实际运行时根据对象类型调用相应的方法
	对于父类中要被重写的方法，使用virtual关键字声明为虚方法
	在子类中使用override关键字重新实现父类虚方法或抽象方法

里氏替换原则：(LSP)
	对象的多态性体现为在继承过程中，子类对象与其父类对象之间的类型转换关系
	向上转型：
		<父类> <应用变量名> = new <子类>
	向下转型
		<子类> <应用变量名> = new <父类>
	无论是向上转型还是向下转型，两个类型之间存在继承关系

方法签名：没有方法体的方法
抽象方法的特征：
	1.抽象方法是影式的虚方法(virtual)
	2.只能在抽象类中声明抽象方法	
	3.抽象方法可以在子类中被实现
	4.抽象方法不可用static和virtual修饰

密封类：由sealed修饰的类(没有子类)	

静态常量和动态常量：const(静态常量)	readonly(动态常量)
	1.const修饰的常量声明的时候必须初始化，readonly修饰的常量可以在代码运行时赋值(只能赋一次)
	2.const修饰的常量在编译期间就被解析(赋初值)，readonly修饰的常量则延迟到运行时被解析(赋初值)
	3.const只能声明简单的数据类型(int、float、double、string、bool)，而readonly除此之外，还可以声明复杂类型(如类)

ReferenceEquals()是Object的静态方法，用于比较两个引用类型的对象是否是对于同一个对象的引用，对于值类型返回false
Equals()是Object的内置方法，支持对于任意两个CTS的比较，有静态版本和重载版本，Equals()针对值类型时是比较两个变量的值是否相等，
针对引用类型时，是比较两个变量的指针(地址)是否相等，这时它和ReferenceEquals()方法功能一致
==一般作用与值类型，这时因为很多类型都对这个操作符进行重载，随意使用很ken产生意料之外的结构

浅复制和深复制
	浅复制：MemberwiseClone(),这个是Object类的方法，复制时不包括对象中的引用类型成员的实际值
	深复制：会使用到ICloneable接口中的Clone()方法，复制时包括对象中的引用类型成员的实际值
	
扩展方法
	1.定义一个静态的类
	2.在静态类中定义一个静态方法，并且访问权限和静态类保持一致
	3.静态方法的第一个参数用于指明此方法是为哪个类扩展的，并且用this修饰
	4.调用扩展方法时，引用(using)扩展方法所在类所在的命名空间
	5.与类型上的实例方法一样的方式调用扩展方法
	
字符串的不可变性
	字符串对象一旦创建，在整个进程的生命周期是不可变的，无法对其进行加长、缩短以及改变等操作
	对于代码str1 += "Hello";CLR会窒息的操作步骤：
		1.开辟新的足够大的临时存储区来容纳要拼接的值
		2.复制str1的值到临时区的开始处
		3.复制"Hello"到临时区的结尾处
		4.释放str1旧的内存
		5.为str1再一次分配内存区
		6.将临时存储区的字符值复制到第五步新开辟的内存区，将str1指向这个内存区的引用
		
字符串的驻留机制
	CLR提供的一种提高性能的对待字符串的机制，它保证在一个进程内相同的字符串在托管内存中只分配一次，
	再次声明相同的字符串对象时，会将后来一次的声明所引用的对象		
	
字符串驻留机制没有解决拼接多个不同的字符串时效率低的问题	